<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jogo de Corrida Lateral - Retrô</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
    color: white;
    font-family: Arial, sans-serif;
  }
  canvas {
    display: block;
    background: #000;
  }
  #hud {
    position: fixed;
    top: 10px;
    left: 10px;
    font-size: 20px;
    z-index: 10;
    user-select: none;
  }
  #gameOver {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 48px;
    color: red;
    display: none;
    user-select: none;
    text-align: center;
    font-family: monospace;
  }
  #startScreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0,0,0,0.85);
    color: white;
    font-weight: bold;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    user-select: none;
    z-index: 20;
    font-size: 80px;
    font-family: monospace;
  }
  #startCount {
    font-size: 28px;
    margin-top: 100px; 
    color: #a64dff; 
    text-shadow: 0 0 5px #ff99ff;
  }
</style>
</head>
<body>

<div id="hud">Pontuação: 0 | Vidas: 3</div>
<div id="gameOver">
  GAME OVER<br />
  <span style="font-size: 24px; margin-top: 20px; display: block;">PRESS SPACE TO RESTART</span>
</div>
<div id="startScreen">
  <div style="font-size:40px; color:#a64dff; text-shadow:0 0 5px #ff99ff;">RETRO RACER</div>
  <div id="startCount">PRESS SPACE TO START</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const hud = document.getElementById("hud");
const gameOverDiv = document.getElementById("gameOver");
const startScreen = document.getElementById("startScreen");
const startCount = document.getElementById("startCount");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const lanes = 4;
let laneHeight = canvas.height / lanes;

let player = {
    width: 50,
    height: 50,
    color: "red",
    speed: 5,
    rotation: 0,
    spinning: false,
    x: 0,
    y: 0
};

let keys = {};
let obstacles = [];

// ----- Velocidades globais -----
const minSpeed = 4;      // velocidade inicial dos CARROS
const maxSpeed = 15;     // velocidade máxima dos CARROS
const speedIncrease = 0.01; 
let gameSpeed = minSpeed; 

let spawnCooldown = 0;
const maxObstacles = 5;
const minObstacleDistance = 250;

// ----- Fundo/estrada -----
let dashOffset = 0;
const bgBaseSpeed = 0;       // fundo começa quase parado
let bgSpeed = bgBaseSpeed;   
const bgMaxSpeed = 8;        // fundo acelera até 8
const bgSpeedIncrease = 0.005; // aceleração gradual do fundo

// flags/estado
let isSlowdown = false;
let score = 0;
let lives = 3;
let gameOver = false;
let gameStarted = false;

function initPlayerPosition() {
    player.x = canvas.width - player.width - 50;
    player.y = 1 * laneHeight + (laneHeight - player.height) / 2;
}

window.addEventListener("keydown", e => {
    keys[e.key.toLowerCase()] = true;

    if (!gameStarted && !gameOver && e.key === " ") {
        startCountdown();
    }

    if (gameOver && e.key === " ") {
        resetGame();
    }
});

window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

function isObstacleTooClose(yPos) {
    for (let obs of obstacles) {
        if (obs.y === yPos && Math.abs(obs.x - canvas.width) < minObstacleDistance) {
            return true;
        }
    }
    return false;
}

function spawnObstacle() {
    if (obstacles.length >= maxObstacles) return;

    let size = 50;
    let possibleLanes = [];
    for (let i = 0; i < lanes; i++) {
        let countInLane = obstacles.filter(o => o.lane === i).length;
        if (countInLane < 2) possibleLanes.push(i);
    }
    if (possibleLanes.length === 0) return;

    let lane = possibleLanes[Math.floor(Math.random() * possibleLanes.length)];
    let obstaclesInLane = obstacles.filter(o => o.lane === lane);

    let yPos;
    if (obstaclesInLane.length === 0) {
        yPos = lane * laneHeight + 10;
    } else {
        yPos = lane * laneHeight + laneHeight - size - 10;
    }

    let dir = (lane === 0 || lane === 2) ? 1 : -1;
    let xPos = dir === 1 ? -size : canvas.width;

    if (isObstacleTooClose(yPos)) return;

    obstacles.push({
        x: xPos,
        y: yPos,
        width: size,
        height: size,
        color: dir === -1 ? "blue" : "green",
        speed: gameSpeed * 1.5, 
        dir: dir,
        lane: lane
    });
}

function isColliding(a, b) {
    return a.x < b.x + b.width &&
           a.x + a.width > b.x &&
           a.y < b.y + b.height &&
           a.y + a.height > b.y;
}

function drawRoad() {
    ctx.fillStyle = "#000033";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#a64dff";
    ctx.fillRect(0, 0, canvas.width, 6);
    ctx.fillRect(0, canvas.height - 6, canvas.width, 6);

    ctx.strokeStyle = "#a64dff";
    ctx.lineWidth = 4;
    ctx.setLineDash([15, 40]);

    for (let i = 1; i < lanes; i++) {
        let y = i * laneHeight;
        ctx.beginPath();
        for (let x = -60 + dashOffset; x < canvas.width; x += 55) {
            ctx.moveTo(x, y);
            ctx.lineTo(x + 15, y);
        }
        ctx.stroke();
    }

    ctx.setLineDash([]);
}

function gameLoop() {
    if (!gameStarted) {
        requestAnimationFrame(gameLoop);
        return;
    }

    if (gameOver) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawRoad();

    // ----- Movimento do fundo -----
    dashOffset += bgSpeed;
    if (dashOffset >= 55) dashOffset = 0;

    if (bgSpeed < bgMaxSpeed) bgSpeed += bgSpeedIncrease;

    // ----- Player -----
    if (!player.spinning) {
        if (keys["w"] && player.y > 0) player.y -= player.speed;
        if (keys["s"] && player.y < canvas.height - player.height) player.y += player.speed;
        if (keys["a"] && player.x > 0) player.x -= player.speed;
        if (keys["d"] && player.x < canvas.width - player.width) player.x += player.speed;
    }

    ctx.save();
    ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
    ctx.rotate(player.rotation);
    ctx.fillStyle = player.color;
    ctx.fillRect(-player.width / 2, -player.height / 2, player.width, player.height);
    ctx.restore();

    // ----- Obstáculos -----
    for (let i = obstacles.length - 1; i >= 0; i--) {
        let obs = obstacles[i];
        obs.x += obs.speed * obs.dir;
        ctx.fillStyle = obs.color;
        ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

        if ((obs.dir === -1 && obs.x + obs.width < 0) ||
            (obs.dir === 1 && obs.x > canvas.width)) {
            obstacles.splice(i, 1);
        } else if (!player.spinning && isColliding(player, obs)) {
            handleCollision();
        }
    }

    // ----- Pontuação -----
    if (!isSlowdown && !player.spinning && gameStarted) {
        score += Math.floor(gameSpeed / 2);
    }

    // ----- Aceleração dos carros -----
    if (!isSlowdown && gameSpeed < maxSpeed && !player.spinning) {
        gameSpeed += speedIncrease;
        if (gameSpeed > maxSpeed) gameSpeed = maxSpeed;
    }

    // ----- Spawn de obstáculos -----
    let spawnRate = Math.max(20, 80 - (gameSpeed * 4));
    if (spawnCooldown <= 0) {
        spawnObstacle();
        spawnCooldown = spawnRate + Math.random() * spawnRate;
    } else {
        spawnCooldown--;
    }

    hud.textContent = `Pontuação: ${score} | Vidas: ${lives} | Velocidade: ${Math.floor(gameSpeed)}`;
    requestAnimationFrame(gameLoop);
}

function handleCollision() {
    lives--;
    if (lives <= 0) {
        gameOver = true;
        gameOverDiv.style.display = "block";
        startScreen.style.display = "none";
        return;
    }

    player.spinning = true;
    isSlowdown = true;
    gameSpeed = Math.max(minSpeed, gameSpeed * 0.5);

    let angle = 0, spinCount = 0;
    let spinInterval = setInterval(() => {
        angle += Math.PI / 10;
        player.rotation = angle;
        player.x -= 2;
        if (player.x < 50) player.x = 50;
        spinCount++;
        if (spinCount > 20) {
            clearInterval(spinInterval);
            player.rotation = 0;
            player.spinning = false;
        }
    }, 30);

    setTimeout(() => {
        isSlowdown = false;
        player.spinning = false;
    }, 2000);
}

function startCountdown() {
    let countdown = 3;
    gameStarted = false;
    startCount.textContent = countdown;
    startScreen.style.display = "flex";
    gameOverDiv.style.display = "none";

    let interval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
            startCount.textContent = countdown;
        } else if (countdown === 0) {
            startCount.textContent = "GO!";
        } else {
            startScreen.style.display = "none";
            gameStarted = true;
            clearInterval(interval);
        }
    }, 1000);
}

function resetGame() {
    score = 0;
    lives = 3;
    gameSpeed = minSpeed;
    isSlowdown = false;
    player.spinning = false;
    player.rotation = 0;
    gameOver = false;
    gameStarted = false;
    obstacles = [];
    spawnCooldown = 0;
    bgSpeed = bgBaseSpeed;
    dashOffset = 0;

    initPlayerPosition();
    gameOverDiv.style.display = "none";
    startScreen.style.display = "flex";
    startCount.textContent = "PRESS SPACE TO START";
    requestAnimationFrame(gameLoop);
}

window.addEventListener("resize", () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    laneHeight = canvas.height / lanes;
    initPlayerPosition();
});

initPlayerPosition();
startScreen.style.display = "flex";
gameLoop();
</script>
</body>
</html>
